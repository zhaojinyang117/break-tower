**游戏设计文档 (GDD) - break tower (暂定名)**

**版本:** 0.2 (填充草稿)
**日期:** 2023年10月27日
**作者:** [Alice]

**目录**

1. **游戏概述 (Game Overview)**
    * 1.1. 核心概念: 一款融合了深度策略卡牌构筑与随机探索元素的网页版肉鸽游戏，以精美的二次元美术风格呈现，玩家将扮演拥有独特能力的角色，挑战不断变化的尖塔（或其他主题场景）。
    * 1.2. 游戏类型: 肉鸽卡牌 (Roguelike Deckbuilder), 卡牌战斗 (Card Battler), JRPG元素。
    * 1.3. 目标平台: 主流PC网页浏览器 (Chrome, Firefox, Edge, Safari 最新版本)。未来可能考虑移动端Web优化。
    * 1.4. 目标用户: 喜欢《杀戮尖塔》、《怪物火车》等肉鸽卡牌游戏的玩家；喜爱二次元美术风格、角色扮演和策略游戏的玩家；寻求可在浏览器中直接游玩、有深度内容的玩家。年龄层：15-35岁。
    * 1.5. 独特卖点 (USP):
        * **选项A (强调角色):** 深度结合二次元角色特性与卡牌机制，每个角色不仅有独特卡组/遗物，更有独特的被动技能甚至战斗中的特殊资源系统。二次元部分主要通过立绘展现，战斗形象则使用2D骨骼动画。
    * 1.6. 拓展：
        * 留出拓展接口，可用于发布dlc，或者发布mod。

    * 1.6. 核心循环:
        1. **开始挑战:** 选择角色，携带初始卡组/遗物进入第一层。
        2. **地图探索:** 在程序随机生成的地图上选择路径前进。
        3. **遭遇节点:** 经历战斗、事件、商店、休息处等不同类型的节点。
        4. **战斗与奖励:** 进行回合制卡牌战斗，胜利后获得卡牌、遗物、金币、药水等奖励。
        5. **构筑强化:** 在探索过程中不断获取/移除/升级卡牌，收集遗物，围绕核心策略构筑卡组。
        6. **事件抉择:** 在随机事件中做出选择，可能获得收益或承担风险。
        7. **Boss挑战:** 击败每层（或特定层）的强大Boss。
        8. **挑战失败/成功:** 若生命值归零则挑战失败，保留局外解锁进度（如有）；成功登顶则完成挑战。
        9. **局外成长:** 根据挑战表现解锁新卡牌、新遗物、新角色、更高难度（飞升等级）等。
        10. **重复挑战:** 开始新的、随机生成的挑战。

2. **游戏玩法机制 (Gameplay Mechanics)**
    * 2.1. 战斗系统
        * 2.1.1. 回合制结构: 玩家回合 -> 敌人回合，循环进行。
        * 2.1.2. 资源系统:
            * **核心:** 能量 (Energy) - 每回合恢复固定值（如3点），用于打出卡牌。
            * **生存:** 生命值 (HP)。
            * **防御:** 护甲/格挡 (Block/Armor) - 每回合结束时通常清零。
            * **角色特殊资源:** 例如：法师的"法力水晶"、剑士的"剑气"、忍者的"连击点"等，通过特定卡牌或行动积攒/消耗，用于强化技能或释放大招。
        * 2.1.3. 卡牌操作: 抽牌 (Draw)、打出 (Play)、弃牌 (Discard)、消耗 (Exhaust)、能力 (Power - 持续生效)、固有 (Innate - 开局在手)、虚无 (Ethereal - 回合结束未打出则消耗)。
        * 2.1.4. 玩家行动: 在自己回合内，消耗能量打出任意数量的卡牌、使用药水（通常不耗能量，有次数限制）、结束回合。
        * 2.1.5. 敌人AI:
            * **意图系统 (Intent System):** 敌人提前显示下回合的行动意图（攻击、防御、施加Debuff、使用特殊技能等），允许玩家针对性应对。
            * **行动模式:** 每个敌人有独特的行动模式组合（可能随机或按顺序），包括攻击力、攻击次数、附加效果等。
            * **复杂AI:** 精英/Boss可能有阶段变化、召唤小怪、特殊反制机制等。
        * 2.1.6. Buff / Debuff 系统: 常见的如力量 (Strength)、敏捷 (Dexterity)、易伤 (Vulnerable)、虚弱 (Weak)、中毒 (Poison)、再生 (Regen)、荆棘 (Thorns) 等。设计符合二次元风格的独特Buff/Debuff（如："羁绊之力"、"元素共鸣"、"心之壁"等）。
        * 2.1.7. 特殊机制:
            * **连击 (Combo):** 打出特定类型或数量卡牌后触发额外效果。
            * **元素系统 (Elemental System):** 卡牌/敌人具有元素属性（火、水、风、雷等），存在克制或增幅关系。
            * **极限爆发/觉醒 (Limit Break / Awakening):** 积攒特殊资源或满足特定条件后，可释放强大的终极技能或进入强化状态。
            * **伙伴/召唤物 (Partner/Summon):** 召唤单位协助战斗（需要设计召唤物生命、攻击、能力）。
    * 2.2. 卡牌系统
        * 2.2.1. 卡牌类型: 攻击 (Attack)、技能 (Skill)、能力 (Power)、状态 (Status - 通常负面效果)、诅咒 (Curse - 负面效果，通常难以移除)。角色专属类型、反应 (Reaction - 特定条件下自动触发)。
        * 2.2.2. 卡牌稀有度: 基础 (Starter)、普通 (Common)、罕见 (Uncommon)、稀有 (Rare)。 传奇 (Legendary)、Boss专属、事件专属。
        * 2.2.3. 卡牌获取: 战斗奖励（通常3选1）、商店购买、事件奖励。
        * 2.2.4. 卡牌移除: 商店服务、事件选项。
        * 2.2.5. 卡牌升级: 休息处（篝火）升级、事件奖励。升级通常强化效果、降低费用或增加特性。
        * 2.2.6. 卡牌效果设计原则: 清晰易懂、具有协同潜力 (Synergy)、提供有意义的选择、符合角色和世界观主题、平衡性。
    * 2.3. 遗物/宝物系统
        * 2.3.1. 遗物效果类型: 开局获得、战斗开始时触发、回合开始/结束时触发、打出特定卡牌时触发、受到伤害时触发、拾取金币时触发、被动属性加成等等。
        * 2.3.2. 遗物稀有度: 初始 (Starter)、普通 (Common)、罕见 (Uncommon)、稀有 (Rare)、Boss (击败Boss获得)、商店 (Shop)、事件 (Event)。
        * 2.3.3. 遗物获取方式: 初始携带、宝箱（击败精英/Boss后）、商店购买、事件奖励。
    * 2.4. 地图/关卡系统
        * 2.4.1. 地图生成: 程序化生成，采用节点与路径连接的形式。通常每层有固定或随机数量的节点排布，路径有分支供选择。参数可调（层数、节点密度、特殊节点出现率）。
        * 2.4.2. 节点类型:
            * **核心:** 普通战斗 (Monster)、精英战斗 (Elite)、Boss战斗 (Boss)、休息处 (Rest Site - 回复HP或升级卡牌)、商店 (Shop)、未知/事件 (Unknown/Event)。
            * 宝藏节点 (Treasure)、特殊角色遭遇节点、挑战节点 (Challenge Room)、迷你Boss节点。
        * 2.4.3. 路径选择: 玩家可以看到前方几步的节点类型，根据当前状态和构筑需求进行路线规划。
    * 2.5. 角色系统
        * 2.5.1. 可玩角色: 计划至少3个初始角色，每个角色有：
            * **独特身份与故事背景** (例如：流浪剑士、见习魔女、守护骑士)。
            * **独特立绘与战斗形象** (考虑二次元风格的多样性)。
            * **不同的初始HP**。
            * **独特的初始卡组** (定义角色核心玩法方向)。
            * **独特的初始遗物** (强化角色特性)。
            * **独特的被动技能或特殊资源系统** (如上文2.1.2所述)。
        * 2.5.2. 角色成长/解锁:
            * **选项B:** 通过积累局外货币或完成特定成就解锁。
    * 2.6. 敌人系统
        * 2.6.1. 普通敌人: 数量较多，能力相对单一，是主要的资源获取来源。设计多种具有不同行为（快攻、防御、放Debuff）的普通敌人组合。
        * 2.6.2. 精英敌人: 能力更强，血量更高，通常有特殊机制，是构筑强度检验器。击败后奖励丰厚（遗物、稀有卡）。
        * 2.6.3. Boss 敌人: 每层（或特定层）的守关者，具有非常强大的能力和复杂的机制，需要玩家有成熟的卡组构筑才能应对。设计具有鲜明二次元特色的Boss形象和技能。
        * 2.6.4. 敌人设计: 包含HP、意图模式、攻击力、技能效果、特殊抗性/弱点、美术形象等。
    * 2.7. 事件系统
        * 2.7.1. 事件触发: 进入地图上的"?"节点。
        * 2.7.2. 选项与结果: 呈现一段描述性文本，提供2-3个选项，每个选项导向不同结果（获得/失去HP、金币、卡牌、遗物；升级/移除卡牌；获得Buff/Debuff；触发战斗等）。
        * 2.7.3. 事件类型: 纯奖励型、风险收益型（赌博）、故事片段型、角色互动型（基于所选角色有不同对话/选项）。大量融入二次元梗或世界观内容。
    * 2.8. 商店系统
        * 2.8.1. 商品类型: 多张卡牌供选择（不同稀有度）、1-2个遗物、药水、卡牌移除服务。卡牌变色/转化服务、特殊商品（需要满足条件）。
        * 2.8.2. 货币系统: 金币 (Gold)。通过战斗、事件获得。
    * 2.9. 药水系统
        * 2.9.1. 药水效果: 提供一次性的、强大的即时效果（治疗、能量、抽牌、临时Buff、对敌Debuff、直接伤害等）。
        * 2.9.2. 药水获取: 战斗掉落、商店购买、事件奖励。玩家有药水槽位限制（如3-5个）。
    * 2.10. MetaProgression / 解锁系统 (如有)
        * 遵循2.5.2的选择，主要通过局外货币/成就解锁角色（以及可选的外观等）。新卡牌/遗物/飞升等级则通过游戏内进度（如首次击败某Boss，达到某层数）自动加入后续随机池（类似StS的解锁）。这是结合了两种模式。
3. **美术与表现 (Art & Presentation)**
    * 3.1. 整体美术风格: 高品质日系二次元美术风格。
        * 3.1.1. 角色设计:
            * **立绘:** 高精度、富有表现力的角色全身像，用于角色选择、对话、图鉴等界面。
            * **战斗形象:**
                * **选项B:** 更接近立绘比例的2D骨骼动画（尝试使用spine）。
        * 3.1.2. 场景/背景设计: 风格化、具有氛围感的战斗背景和地图界面，符合世界观设定（幻想、科技、和风等）。
        * 3.1.3. 卡面设计: 精美插画，清晰展示卡牌效果和关键信息，风格统一。
        * 3.1.4. UI/UX 视觉风格: 简洁、现代，融入二次元设计元素（如渐变色、特效边框、特定字体、萌系图标）。信息层级清晰。
    * 3.2. 动画与特效 (Animation & Visual Effects - VFX)
        * 3.2.1. 角色动画: 流畅的待机、攻击、施法、受击、闪避、格挡、阵亡动画。若使用Live2D/Spine，则需要更丰富的表情和动作变化。
        * 3.2.2. 卡牌效果表现: 视觉冲击力强、清晰区分不同效果（伤害、格挡、Buff/Debuff施加、抽牌等）的特效。大量运用粒子效果、光效、刀光剑影等。
        * 3.2.3. UI反馈动画: 按钮点击、菜单切换、资源变化（HP增减、能量获得）等应有平滑过渡和反馈动画。
        * 3.2.4. 特效风格: 华丽而不失辨识度，符合整体二次元幻想/科技风格。
    * 3.3. 用户界面 (User Interface - UI)
        * 3.3.1. 布局:
            * **战斗界面:** 玩家手牌区域、抽牌堆/弃牌堆/消耗堆、能量/HP/护甲显示、药水栏、遗物栏、敌人区域（含意图、HP、Buff/Debuff）、回合结束按钮。参考StS但可做风格化调整。
            * **地图界面:** 清晰展示节点、路径、当前位置、图例。
            * **其他界面:** 卡组浏览、遗物查看、角色选择、主菜单、设置、商店、休息处、事件对话框。
        * 3.3.2. 核心信息展示: 必须时刻清晰可见玩家和敌人的HP、护甲、能量、Buff/Debuff状态、敌人意图、卡牌费用和效果描述（鼠标悬停/点击查看详情）。
        * 3.3.3. 交互设计:
            * **卡牌:** 拖拽到目标或战场中心打出；点击查看大图和详细描述。
            * **目标选择:** 清晰的指向提示（如需指定敌人）。
            * **按钮/节点:** 明确的点击区域和反馈。
    * 3.4. 用户体验 (User Experience - UX)
        * 3.4.1. 操作流畅度: 保证高帧率运行，卡牌拖拽、动画播放无卡顿。快速响应用户输入。
        * 3.4.2. 信息清晰度: Tooltip无处不在，解释所有图标、状态、卡牌关键词。战斗日志记录关键事件。
        * 3.4.3. 新手引导: 简洁明了的初始教程，解释核心规则。 上下文提示系统，在玩家首次遇到新机制时弹出说明。
        * 3.4.4. 视觉反馈: 每次操作（打牌、受伤、格挡成功/失败、Buff/Debuff生效）都有即时、明确的视觉和音效反馈。
    * 3.5. 音频设计
        * 3.5.1. 背景音乐 (BGM): 为不同场景（菜单、地图、普通战斗、精英战斗、Boss战、商店、休息处、事件）创作符合氛围的、具有二次元风格的音乐。
        * 3.5.2. 音效 (SFX): 为卡牌打出（按类型区分）、攻击命中、格挡、技能效果、敌人行动、UI交互（按钮、抽牌、洗牌）、物品拾取等制作丰富且有辨识度的音效。
        * 3.5.3. 角色语音 (Voice Acting): **（高优先级）** 为角色添加关键时刻的语音（如选择角色、使用特定强力卡牌、低血量、胜利/失败），极大增强二次元代入感。

4. **叙事与世界观 (Narrative & World)**
    * 4.1. 世界观设定: **（选择其一或融合）**
        * **选项A (幻想高塔):** 一个充满魔法与神秘生物的巨大高塔，塔顶隐藏着某种力量或秘密，吸引着各路英雄前来挑战。
    * 4.2. 故事背景: 简要说明世界现状，以及"尖塔"（或对应场景）为何存在，玩家挑战的目标是什么（拯救世界？寻求力量？揭开真相？）。
    * 4.3. 角色背景故事: 为每个可玩角色撰写简洁的背景故事，解释他们的能力来源、动机以及与其他角色/世界观的联系。
    * 4.4. 叙事方式: 主要通过随机事件的文本描述、遗物的风味文字 (Flavor Text)、Boss战前后的少量对话、特定节点的特殊剧情来展现。开场/结局的静态CG+文本。

5. **技术规格 (Technical Specifications)**
    * 5.1. 目标平台细节: 确保在最新版 Chrome, Firefox, Edge, Safari 上流畅运行。考虑响应式布局以适应不同浏览器窗口大小。
    * 5.2. **前端技术栈 (Frontend Stack)**
        * 5.2.1. 核心语言: **TypeScript** (利用强类型提高代码质量和可维护性)。
        * 5.2.2. 游戏引擎/渲染库:
            * **Phaser:** 功能全面，社区活跃，包含物理、动画、资源管理等，开发效率高。适合复杂度较高的游戏。
        * 5.2.3. UI 库 :
            * **方案一:** 完全使用游戏引擎/库提供的UI组件（如Phaser DOM元素或PixiJS的图形绘制/文本）。
        * 5.2.4. 状态管理:
            * **方案一:** 使用面向对象的类和模块来封装和管理游戏状态（玩家、敌人、卡组、战斗流程等）。
    * 5.3. **后端技术栈 (Backend Stack)**
        * 5.3.1. 核心语言: **Python** (选择最新稳定版本，如 3.9+)。
        * 5.3.2. Web 框架:
            * **Django:** 功能全面，自带ORM、Admin后台，开发效率高，适合需要复杂后台管理或快速原型验证的场景。
        * 5.3.3. 数据库:
            * **核心数据 (用户、进度、解锁内容):** **PostgreSQL** (功能强大，稳定可靠)
            * **日志:** 使用Python的logging库将日志输出到文件或stdout
        * 5.3.4. API 协议:
            * **RESTful API:** 成熟、标准、生态丰富，前后端沟通常用方式。
        * 5.3.5. 认证方式: **JWT (JSON Web Tokens)** - 无状态认证，适合SPA（单页应用）。
    * 5.4. 数据格式: 使用 **JSON** 文件定义卡牌、遗物、敌人、事件等配置数据。便于前端加载和后端（可能）的管理。
    * 5.5. 存档机制
        * 5.5.1. 本地存储:
            * **`localStorage`:** 用于存储简单的用户设置（音量、画质偏好等）。
            * **`IndexedDB`:** 用于存储单局游戏过程中的临时状态（允许关闭浏览器后快速恢复当前run，有容量限制）。
        * 5.5.2. 云存档: 通过 **后端API** 将核心进度（解锁内容、最高层数、角色经验/等级如有）保存到 **后端数据库**。需要用户登录。（初期可以只实现保存解锁进度、最高分数/层数、局外货币等永久性数据。单局内的进度恢复可以优先依赖 IndexedDB 在本地实现（浏览器关闭重开可恢复））
    * 5.6. 资源管理与加载: 利用游戏引擎/库的资源加载器。使用 **Texture Atlas** (纹理图集) / **Sprite Sheets** 减少绘制调用。考虑 **按需加载** 或 **后台预加载** 资源，优化初始加载时间。使用压缩格式（如 WebP for images, Ogg Vorbis/Opus for audio）。
    * 5.7. 性能要求与优化点:
        * 目标帧率: 60 FPS。
        * 优化: 减少Draw Call（渲染批处理）、优化图片资源（大小、格式、图集）、合理使用对象池 (Object Pooling) 管理频繁创建销毁的对象（如子弹、特效）、避免复杂的同步计算阻塞主线程、优化JavaScript/TypeScript代码执行效率（减少GC）、Web Worker（用于后台复杂计算）、代码分割 (Code Splitting) 减少初始JS加载体积。关注内存使用，防止泄漏。
    * 5.8. "可扩展性设计"：
        * 简要说明需要在数据结构（如JSON格式要易于扩展）、代码组织（模块化，避免硬编码）、可能的API接口（如果Mod需要与后端交互）等方面为未来的DLC和Mod预留可能性。

6. **内容清单 (Content List - 示例目标)**
    * 6.1. 可玩角色: 3 个 (具有独特机制和卡池)
    * 6.2. 卡牌数量: 总计约 250+ 张 (每个角色约 70-80 张独特卡牌 + 30-50 张中立/无色卡牌)
    * 6.3. 遗物数量: 总计约 100-150 个 (覆盖各种稀有度和来源)
    * 6.4. 敌人种类: 总计约 40-50 种 (普通 ~25-30, 精英 ~10-15, Boss 3-5 个 + 最终Boss)
    * 6.5. 事件数量: 约 60-80 个 (提供多样选择和故事片段)
    * 6.6. 药水种类: 约 12-18 种
    * 6.7. 关卡层数: 3 个主要层级 (Acts) + 1 个最终Boss层。

7. **开发计划与里程碑 (Development Plan & Milestones - 粗略)**
    * **M1: 核心战斗原型:** 实现基础回合制、能量系统、卡牌抽打弃、HP/护甲、敌人意图与基础攻击。TS + (Phaser)。(目标：验证核心玩法乐趣)
    * **M2: 基础系统框架:** 地图生成与导航、节点类型（战斗/休息/事件）、卡牌/遗物获取与展示、存档/读档（本地临时）。
    * **M3: 内容填充 I:** 完成第一个角色的基础卡组和少量进阶卡牌、第一层敌人（普通/精英/Boss）、少量遗物、基础事件。
    * **M4: 美术整合 I & UI/UX:** 导入第一批美术资源（角色战斗形象、卡面、UI基础风格），实现核心UI布局和交互。选择并集成2D动画系统并实现基础战斗动画"。
    * **M5: 后端基础:** Python后端项目搭建，实现用户注册/登录 (JWT)，基础云存档API (保存/加载解锁进度)。
    * **M6: 系统完善 & 内容填充 II:** 实现商店、药水系统、更多卡牌/遗物/敌人/事件，完成第二个角色。前后端联调存档功能。
    * **M7: Alpha测试 & 平衡调整:** 内部测试，收集反馈，重点调整卡牌/遗物/敌人强度和协同性。实现排行榜功能（后端）。
    * **M8: 内容完成 & 美术/音效完善:** 完成所有计划内容（第三角色、所有卡牌/遗物/敌人/事件），加入完整音效、BGM、角色语音（如果做）。优化视觉效果和动画。
    * **M9: Beta测试 & 最终优化:** 开放小范围测试，进行最后的BUG修复、性能优化和平衡性调整。完善新手引导。
    * **M10: 发布准备 & 上线:** 部署到服务器，市场宣传（如果需要），正式发布。

8. **盈利模式 (Monetization)**
    * **选项A (推荐):** 游戏本体免费。通过 **出售外观** (Cosmetics) 盈利，如角色皮肤、卡背图案、战斗场景皮肤、特效皮肤。不影响平衡性。
    * **选项B:** 游戏本体免费。提供 **付费DLC/扩展包**，包含新的可玩角色、新的关卡/敌人、大量新卡牌和遗物。
    * **混合模式:** 例如 本体免费+外观付费+付费DLC。

9. **附录 (Appendix)**
    * （待补充）概念美术、UI线框图、核心战斗流程图、数值设计草案。

# MVP (Minimum Viable Product - 最小可行产品)

* 构成游戏核心乐趣绝对必要的特性（基础战斗、卡牌/遗物系统、地图探索、1个角色），必须在第一个可玩版本中实现
* 角色美术资源先采取静态图片

# 开发计划

**详细开发计划 - break tower (程序方面)**

**目标：** 基于GDD v0.2和明确的MVP定义，制定详细的、可执行的、以编程为重点的开发计划。

**指导原则：**

* **MVP优先：** 优先实现构成游戏核心乐趣的最小可行产品所需的特性。
* **迭代式：** 首先构建核心系统，然后逐步增加复杂性和内容。
* **技术栈：** 任务专为TypeScript + Phaser (前端) 和 Python + Django + PostgreSQL (后端) 量身定制。
* **占位符美术资源：** 初始里程碑使用静态图像（立绘），如MVP定义所述。动画集成将在后面进行。
* **详细任务：** 将特性分解为更小、可管理的编码任务。
* **测试：** 在整个过程中集成测试（单元、集成、端到端），而不仅仅是在最后。

---

**阶段1：MVP实现 (包含静态美术资源的核心玩法循环)**

**里程碑1：核心战斗原型 (基础)** ✅

*目标：创建一个基本的、可玩的回合战斗场景，玩家可以向一个基本敌人打出卡牌。*

* **前端 (TS + Phaser):**
  * **✅ 任务 1.1 (设置):** 创建基本的Phaser项目结构（场景、资源文件夹）。设置TypeScript编译。
  * **✅ 任务 1.2 (场景):** 实现 `CombatScene.ts`。处理基本的场景生命周期（preload, create, update）。
  * **✅ 任务 1.3 (实体):**
    * 创建 `Player.ts` 类：管理生命值 (HP)、能量 (Energy)、护甲/格挡 (Block) 状态。渲染一个简单的静态占位符精灵。
    * 创建 `Enemy.ts` 类：管理生命值 (HP)、意图 (Intent) 状态。渲染一个简单的静态占位符精灵。基本定位逻辑。
  * **✅ 任务 1.4 (资源):** 实现UI元素（简单的文本/图形）以显示玩家的HP、能量、格挡；敌人的HP、意图（例如，"攻击 5"）。
  * **✅ 任务 1.5 (卡牌数据):** 定义 `CardData.ts` 接口/类（ID、名称、费用、类型、描述、效果定义 - 初始为简单版本）。创建示例 `cards.json`。实现基本的JSON加载。
  * **✅ 任务 1.6 (卡牌管理):**
    * 创建 `DeckManager.ts`：管理抽牌堆、手牌、弃牌堆。实现 `drawCard()`、`discardCard()`、`shuffleDiscardIntoDraw()` 方法。
    * 实现基本的手牌渲染：在玩家的手牌区域中显示静态卡牌占位符。
  * **✅ 任务 1.7 (卡牌交互):** 实现基本的卡牌点击/拖拽检测。在有效打出（有足够的能量）时：
    * 扣除能量费用。
    * 将卡牌视觉效果从手牌移动到弃牌堆视觉效果区域。
    * 触发基本效果执行（参见任务 1.8）。
  * **✅ 任务 1.8 (效果系统 - 最小化):** 创建 `EffectRunner.ts`。为MVP实现*非常基本*的效果处理程序：
    * `dealDamage(target, amount)`
    * `gainBlock(amount)`
  * **✅ 任务 1.9 (回合管理):** 创建 `TurnManager.ts`（或在 `CombatScene` 中管理）：
    * 实现状态：`PLAYER_TURN`、`ENEMY_TURN`。
    * 玩家回合开始：重置格挡（玩家），获得能量，抽取卡牌。
    * 玩家回合结束：触发敌人回合。添加"结束回合"按钮。
    * 敌人回合开始：执行存储的意图（任务 1.10）。
    * 敌人回合结束：计算下一个意图，显示它，触发玩家回合开始。
  * **✅ 任务 1.10 (敌人AI - 最小化):** 在 `Enemy.ts` 中，实现逻辑以：
    * 选择一个简单的下一个意图（例如，总是攻击固定伤害）。
    * 存储并显示此意图。
    * 执行意图（例如，调用 `Player.takeDamage()`）。
  * **✅ 任务 1.11 (战斗结束):** 在受到伤害后实现基本的HP检查。如果玩家HP <= 0 或 敌人HP <= 0，则在场景中触发一个简单的"胜利/失败"状态/消息。

**里程碑 2：基本系统框架 (连接循环)**

*目标：将战斗连接到更大的游戏结构（地图探索）。在战斗之外添加核心物品/卡牌管理。*

* **前端 (TS + Phaser):**
  * **任务 2.1 (地图数据):** 定义地图节点和路径的数据结构。实现 `MapGenerator.ts` 用于基本的程序化生成逻辑（例如，简单的分层图）。
  * **任务 2.2 (地图场景):** 实现 `MapScene.ts`。
    * 可视化地渲染生成的地图节点和路径。
    * 显示玩家当前位置标记。
    * 处理玩家输入以选择沿有效路径的下一个节点。
  * **任务 2.3 (Run状态):** 创建 `RunState.ts` (或类似的服务) 以保存持久的Run数据：玩家当前/最大HP，金币（初始为0），当前卡组（卡牌ID），已获得的遗物（ID，初始为空）。此状态需要在场景之间保持。
  * **任务 2.4 (场景过渡):** 实现 `MapScene` 和 `CombatScene` 之间的切换逻辑（以及稍后其他节点场景，如 `RestScene`、`EventScene`）。传递必要的上下文（例如，`CombatScene` 的敌人遭遇ID）。确保 `RunState` 被保留。
  * **任务 2.5 (节点逻辑):** 在 `MapScene` 中，进入一个节点时：
    * 如果是战斗节点：过渡到 `CombatScene`，传递敌人遭遇ID。
    * 如果是休息/事件/商店节点：（目前）显示一个占位符消息，并允许移动到下一个节点。
  * **任务 2.6 (战斗奖励 - 基本):** 在 `CombatScene` 中，在胜利时：
    * 生成基本奖励（例如，固定数量的金币）。更新 `RunState`。
    * 实现基本的卡牌奖励界面（`CardRewardScene.ts` 或覆盖层）：显示3个卡牌选择（来自 `cards.json` 的静态占位符）。允许选择一个。更新 `RunState.deck`。
    * 过渡回 `MapScene`。
  * **任务 2.7 (卡组/遗物查看 - 基本):** 实现一个简单的覆盖层或单独的场景 (`DeckViewScene.ts`)，可以从地图访问以查看当前卡组中的卡牌（静态卡牌名称/占位符的列表）。基本的遗物显示区域（目前为空）。
  * **任务 2.8 (本地保存/加载 - Run状态):**
    * 实现将 `RunState` 序列化为JSON的函数。
    * 在移动地图或关闭时，使用 `IndexedDB` 保存序列化的run状态。
    * 在游戏开始时，检查 `IndexedDB` 中是否有已保存的run状态，并提供恢复（加载并反序列化到 `RunState`，从 `MapScene` 中的已保存位置开始）。

**里程碑 3：内容填充I & 核心系统扩展 (MVP完成)**

*目标：用第一个真实角色、卡牌、敌人填充MVP框架，并使其*感觉*像一个游戏。*

* **前端 (TS + Phaser):**
  * **任务 3.1 (角色系统 - 基本):**
    * 实现 `CharacterData.ts` (ID、名称、初始HP、初始遗物ID、初始卡组ID)。
    * 实现基本的角色选择屏幕（最初只显示一个角色）。
    * 在开始一个新的Run时，根据选择的角色数据初始化 `RunState`。
  * **任务 3.2 (卡牌系统扩展):**
    * 在 `EffectRunner.ts` 中，实现更多的效果处理程序：获得临时HP、抽牌、获得能量、应用Buff/Debuff（基本版本）。
    * 实现卡牌目标选择：允许将卡牌拖拽到有效目标（自身、特定敌人、所有敌人）。更新效果处理程序以使用目标信息。
    * 实现卡牌升级逻辑：在 `cards.json` 中定义升级后的卡牌版本。在 `RestScene`（任务 3.7）中，允许选择一个卡牌以在 `RunState.deck` 中替换为它的升级版本。
  * **任务 3.3 (遗物系统 - 基本):**
    * 定义 `RelicData.ts` 接口/类 (ID、名称、描述、效果触发器、效果定义)。创建示例 `relics.json`。
    * 创建 `RelicManager.ts`：持有已获得的遗物ID（在 `RunState` 中）。
    * 在相关系统中实现基本的遗物效果触发钩子（例如，`CombatScene.onCombatStart()`、`TurnManager.onTurnStart()`、`Player.onTakeDamage()`）。这些钩子检查已获得的遗物并调用 `EffectRunner` (如果触发了遗物效果)。
    * 实现基本的遗物奖励：将获得的遗物ID添加到 `RunState`。更新遗物查看UI。
  * **任务 3.4 (敌人AI扩展):**
    * 在配置文件 (`enemies.json`) 中定义更多敌人类型，具有不同的HP、AI模式（意图序列，如攻击 -> 防御 -> 施加Buff）。
    * 更新 `CombatScene` 敌人生成以从这个配置中提取基于遭遇ID的敌人。
    * 实现精英/Boss的指定：在配置中标记特定的敌人。精英掉落遗物（任务 3.3）。Boss结束该层（Act）。
  * **任务 3.5 (事件系统 - 基本):**
    * 实现 `EventScene.ts`。接受一个事件ID。
    * 定义 `EventData.ts` (ID、文本、选项[{文本、结果}])。创建示例 `events.json`。
    * `EventScene` 基于事件ID显示文本和选项按钮。
    * 实现 `EventOutcomeHandler.ts`：基于选择的选项执行结果（例如，获得/失去HP/金币、获得卡牌/遗物、开始战斗）。更新 `RunState`。过渡回 `MapScene`。
  * **任务 3.6 (Buff/Debuff系统 - 基本):**
    * 实现 `BuffManager.ts`（附加到Player/Enemy）。跟踪激活的Buff（ID、持续时间/层数）。
    * 在 `EffectRunner` 中实现基本的Buff效果：力量、敏捷、易伤、虚弱。在 `BuffManager` 中应用/更新层数。
    * 实现基于回合的持续时间递减逻辑。
    * 在Player/Enemy UI上可视化显示激活的buff/debuff。
  * **任务 3.7 (休息处):** 实现 `RestScene.ts`。提供选择：
    * 治疗：恢复一定比例的HP（更新 `RunState.hp`）。
    * 升级：允许从卡组查看UI (任务 2.7增强) 选择一张卡牌进行升级 (任务 3.2)。
    * 过渡回 `MapScene`。

**阶段 2：优化、后端集成和功能扩展**

**里程碑 4：美术集成I & UI/UX 优化**

*目标：用初始美术资源替换占位符，集成选择的动画技术，优化UI反馈。*

* **前端 (TS + Phaser):**
  * **任务 4.1 (资源加载):** 实现使用Phaser的加载器进行高效的资源加载，可能带加载条。加载角色、敌人、卡牌、背景、UI元素实际的静态图像资源。在适当的地方使用Texture Atlases。
  * **任务 4.2 (静态美术资源替换):** 更新所有渲染代码（Player、Enemy、Card、UI）以使用加载的静态美术资源，而不是占位符。
  * **任务 4.3 (动画系统集成 - Spine):**
    * 集成Spine Phaser Runtime（或选择的2D动画库运行时）。
    * 修改 `Player.ts` / `Enemy.ts` 以加载和显示Spine模型而不是静态精灵。
    * 创建helper函数来播放动画（例如，`playIdle()`、`playAttack()`、`playHit()`、`playDie()`）。
  * **任务 4.4 (基本动画触发):** 连接动画调用：
    * 在 `update()` 中播放待机动画。
    * 攻击时播放攻击动画。
    * 受到伤害时播放受击动画。
    * HP <= 0时播放死亡动画。
  * **任务 4.5 (UI 优化):** 使用Phaser的UI组件（如果需要，也可以使用DOM元素）实现设计的UI布局。为反馈添加Tween动画（按钮点击、资源变化）。实现卡牌、遗物和Buff Tooltips。
  * **任务 4.6 (VFX - 基本):** 使用Phaser的粒子系统为伤害冲击、治疗、Buff施加实现简单的粒子效果。

**里程碑 5：后端基础**

*目标：设置后端服务器和数据库，实现基本用户帐户和云存档的第一步（解锁）。*

* **后端 (Python + Django):**
  * **任务 5.1 (项目设置):** 创建Django项目和应用。配置设置（数据库、已安装的应用）。设置 `requirements.txt`。
  * **任务 5.2 (数据库模型):** 定义初始Django模型：`User`（使用内置或自定义），`PlayerProfile`（与User的一对一关系，字段用于unlocked_cards: JSONField, unlocked_relics: JSONField, unlocked_characters: JSONField, highest_ascension: IntegerField等）。
  * **任务 5.3 (数据库设置):** 配置PostgreSQL连接。运行 `makemigrations` 和 `migrate`。
  * **任务 5.4 (API框架):** 集成Django REST Framework (DRF)。配置基本的DRF设置。
  * **任务 5.5 (认证API):**
    * 使用DRF序列化器和视图实现用户注册端点 (`/api/auth/register/`)。
    * 实现用户登录端点 (`/api/auth/login/`) - 成功后返回JWT token（使用 `djangorestframework-simplejwt`）。
  * **任务 5.6 (解锁保存/加载API):**
    * 实现受保护的端点 (`/api/profile/`) (需要JWT认证):
      * `GET`: 返回已登录用户的 `PlayerProfile` 数据（解锁）。
      * `PUT/PATCH`: 更新已登录用户的 `PlayerProfile` 数据（例如，添加新解锁的卡牌ID）。使用DRF序列化器进行验证。
  * **任务 5.7 (基本管理):** 配置Django Admin站点，以便在开发期间轻松查看/管理用户和PlayerProfile。

**里程碑 6：系统完成与内容II**

*目标：实现剩余的核心系统（商店、药水）、添加第二个角色、连接前端认证/解锁。*

* **前端 (TS + Phaser):**
  * **任务 6.1 (商店系统):** 实现 `ShopScene.ts`。根据配置生成物品（卡牌、遗物、药水、移除服务）。处理购买逻辑（检查金币、更新 `RunState`、从商店中删除物品）。
  * **任务 6.2 (药水系统):** 定义 `PotionData.ts`。实现药水栏UI。实现药水使用逻辑（触发 `EffectRunner`）。处理获得药水（奖励、商店）。
  * **任务 6.3 (角色II):** 实现第二个角色的数据和具体机制/资源。更新角色选择屏幕。
  * **任务 6.4 (内容):** 实现更多卡牌、遗物、敌人和事件的数据和逻辑。
  * **任务 6.5 (后端集成 - 认证):**
    * 实现登录/注册表单的UI。
    * 使用 `fetch` 或 `axios` 调用后端认证API（任务 5.5）。安全地存储JWT token（例如，`localStorage`）。
    * 实现逻辑以在header中发送JWT token以进行经过身份验证的API调用。
  * **任务 6.6 (后端集成 - 解锁):**
    * 在游戏开始时（登录后），调用后端API（任务 5.6 GET）以获取已解锁内容数据。使用此数据来填充卡牌/遗物/角色可用性。
    * 当在游戏内解锁一个新物品/角色/飞升时，调用后端API (任务 5.6 PUT/PATCH) 以保存更新。
* **后端 (Python + Django):**
  * **任务 6.7 (优化):** 根据前端集成需求，优化API响应和错误处理。

**里程碑 7：Alpha测试与平衡工具和排行榜**

*目标：内部测试，实现更轻松的平衡工具，添加排行榜。*

* **前端 (TS + Phaser):**
  * **任务 7.1 (调试工具):** 实现简单的调试控制台/命令（例如，添加金币、给予卡牌/遗物、设置HP）以方便测试。
  * **任务 7.2 (分析钩子 - 可选):** 添加代码以跟踪关键事件（Run开始/结束、Boss击杀、卡牌选择）并将数据发送到潜在的后端分析端点（如果计划进行分析）。
  * **任务 7.3 (排行榜UI):** 实现UI屏幕以显示从后端获取的排行榜数据。
* **后端 (Python + Django):**
  * **任务 7.4 (平衡端点 - 可选):** 可能会创建一个端点以从服务器获取核心平衡数据（卡牌统计信息、敌人HP等），而不是仅仅从本地JSON获取，从而允许更快的调整。（需要管理界面才能编辑）。
  * **任务 7.5 (排行榜模型):** 定义 `LeaderboardEntry` 模型（外键到User、分数、角色、飞升、日期）。
  * **任务 7.6 (排行榜API):**
    * 实现提交Run结果的端点（分数等） - 创建一个 `LeaderboardEntry`。
    * 实现获取顶部排行榜条目的端点（例如，总体前N名，特定角色/飞升的前N名）。

**里程碑 8：内容完成和优化II（音频/VFX）**

*目标：添加所有计划的内容，集成最终音频，优化动画/VFX。*

* **前端 (TS + Phaser):**
  * **任务 8.1 (角色 III):** 实现第三个角色。
  * **任务 8.2 (最终内容):** 实现剩余的卡牌、遗物、敌人（最终Boss！）、事件。
  * **任务 8.3 (音频集成):** 实现 `AudioManager.ts`。加载BGM和SFX。在整个代码库中添加调用以在适当的时间播放声音（UI点击、卡牌打出、攻击、环境声音）。
  * **任务 8.4 (动画/VFX优化):** 优化Spine动画（更具表现力的动作、过渡）。为能力、Buff、环境添加更详细和更具冲击力的粒子效果。
  * **任务 8.5 (优化I):** 分析渲染性能。优化资源使用（压缩纹理，如果需要，减少图集大小）。审查对象创建/销毁，可能会为频繁的效果/弹药实现基本对象池。

**里程碑 9：Beta测试和最终优化**

*目标：更广泛的测试、错误修复、深入的性能优化、教程。*

* **前端 (TS + Phaser):**
  * **任务 9.1 (Bug修复):** 解决在Alpha/Beta测试期间发现的错误。
  * **任务 9.2 (性能优化II):**
    * 使用浏览器性能分析工具进行深入分析。
    * 优化复杂的计算或循环。
    * 使用Webpack/Rollup/Parcel实现代码分割以减少初始加载时间。
    * 优化Phaser对象管理（池化、剔除）。
  * **任务 9.3 (教程系统):** 实现初始教程序列（脚本化事件/提示，解释核心机制）。
  * **任务 9.4 (上下文帮助):** 实现一个系统，当遇到新的机制时，显示帮助工具提示/弹出窗口（例如，第一次看到消耗）。
* **后端 (Python + Django):**
  * **任务 9.5 (可扩展性/安全性审查):** 审查数据库查询的效率。检查API端点是否存在潜在的安全漏洞（输入验证、授权检查）。

**里程碑 10：发布准备与上线**

*目标：最终部署设置、构建过程、监控。*

* **前端 (TS + Phaser):**
  * **任务 10.1 (构建过程):** 配置生产构建过程（最小化、混淆、代码分割）。
  * **任务 10.2 (部署):** 将前端静态文件部署到托管服务（Netlify、Vercel、S3/CloudFront或自己的服务器）。
* **后端 (Python + Django):**
  * **任务 10.3 (服务器设置):** 配置生产服务器环境（例如，带有Nginx、Gunicorn/Uvicorn、PostgreSQL的Linux服务器）。对敏感设置使用环境变量。
  * **任务 10.4 (部署):** 将Django应用程序部署到服务器。设置进程管理（Supervisor、systemd）。
  * **任务 10.5 (日志/监控):** 配置生产日志记录。设置服务器健康和API响应时间的基本监控。
  * **任务 10.6 (数据库备份):** 实施定期的数据库备份策略。

---

## 重构计划完成情况

✅ 已完成项目重构，包括：

* 创建新的目录结构
* 移动和重组现有文件
* 更新导入路径
* 测试确保功能正常

额外完成的工作（计划外）：

* 创建了新的场景：DeckViewScene 和 RewardScene
* 添加了ESLint和Prettier配置
* 创建了README.md和LICENSE文件
* 优化了游戏的自适应显示，解决了黑边问题

---
